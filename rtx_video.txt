перед началом видео отмечу, что я пока что не силён в программировании поэтому могу иногда произносить неверные или неточные термины

Всем привет, я Влад авокадо и сегодня я расскажу вам как вы можете сделать самую простую 3д графику с освещением и тенями в консоли с нуля, подкрепляя ваши знания теорией

прежде всего стоит понимать что мы рассматриваем консоль как декартовую систему координат и при выводе опираемся на это, и наша первая задача это вывести просто квадрат,но для этого нам
надо откуда-то взять x и y в моя консоль показывает размер 196 на 54, то есть если хотим выводить что-то кадрами, то в них должно быть 54 строчки шириной в 196 символов, сейчас код для
вывода квадрата работает так: мы проверяем каждую координату x относительно текущей координаты y и если она подходит под условия в которых находится квадрат, выводим символ, если нет,
то выводим пробел. И тут мы можем заметить первую странность: у нас вывелся не квадрат, а прямоугольник, это связано с тем, что в высоту символы больше чем ширину и это нормально, в
начале видео я упомянул про освещение, поэтому сейчас и добавим его: почти в самом начале программы делаем массив из символов gradient и пихаем туда символы от большего к меньшему, а
затем изменяем вывод квадрата: создаём в основном цикле целочисленную переменную index в котором высчитываем длину вектора по теореме пифагора и делим на значение, от которого будет
зависить сила света, я пока решил делить просто на размер массива делённый на пополам, почти таким же образом делаем круг, немного изменяя то, при каких условиях будет выводиться
символ. Теперь возникает другая проблема: когда мы хотим вывести две фигуры, то они выводятси по отдельности, а не вместе, для исправления данной ошибки надо добавить буфер, который
позволит нам выводить несколько фигур одновременно, но перед тем как туда что-либо записывать, надо его инициализировать, потэтому добавляем в начало программы три функции:
инициализация, вывод и удаление из памяти, так как буфер будет динамическим, если с выводом и удалением всё итак понятно, так как они работают также, как и инициализация, то её мне
стоит объяснить немного подробнее: сначала мы создаём пустой указатель указывающий на другой указатель, который указывает тип char, затем, в самой функции, мы делаем по сути то же
самое, что и до этого: создаём все x и y и пока что записываем в них только пробелы. А теперь самое интересное: запись фигур в этот буфер, до этого мы перебирали
каждый символ, но теперь мы можем выбрать и перезаписать конкретно те символы в буфере, которые нам нужны, а не всё целиком и вывод прекрасно работает, и ещё я вывел размер градиента в
отдельную переменную, чтобы не считать её каждый раз по новой.

Согласитесь, то что выводить степерь освещения обычными символами не очень красиво, мы же не в 60-х чтобы такое делать, хорошо что мы живём в мире в котором есть символы unicode в
которых есть целых четыре символа использующихся для того, чтобы показать градиент, поэтому стоит внедрить минимум изменений для поддержки локали в программе, изменив тип с char на
wchar_t, кстати, функция sizeof из библиотеки iterator возвращает количество байт, которые занимает массив, потэтому в gradient_size мы делим то, сколько места занимает массив, на то,
сколько места занимает тип переменной.

Итак, самая главная часть видео, добавление теней и 3д: теперь буфер не создаётся как пустой указатель указывающий на другой указатель, который указывает тип char, а как пустой
указатель указывающий на другой указатель,который указывает на ещё один указатель, который указывает тип char и при инициализации добавляем координату z и пол на координатах когда y
равен нулю, для этого выводим переменные в которых указываем координаты света отдельно, к огромному сожалению мои знания в геометрии недостаточны для того чтобы выводить сцену из разных
положений, поэтому ограничусь проекциями сверху, справа и спереди, в записи фигур мы просто добавляем перечисление так же и для координаты z, по сути дублируя определение координаты
x,потому что теорема Пифагора спокойно работает и на трёхмерных векторах, а вот с тенью придётся снова углубиться в теорию, для удобства буду показывать на двухмерной системе координат:
представим что вектор света, который дошёл до фигуры продолжил движение и дошёл до пола, это и будет тень, обозначим её пока что английской буквой s чтобы понять что всё работает
правильно, как видно из работы программы, в некоторых местах тень не создаётся, честно говоря я не снаю с чем это связано,скорее всего с округлением чисел, поэтому оставлю как есть.

Вот мы уже и на финишной прямой, изначально я хотел сделать чтобы тень падала и на объекты, но благополучно на это забил,, прямо как разработчики half-life:source, но мне это
простительно, а им нет,потому что придётся делать дополнительный слой обработки, в котором нужно будет ещё и опираться на угол падения вектора, поэтому в месте где у нас должна быть
тень просто выводим последний элемент из массива с градиентом, а также добавляю проверку на то, выходят ли точки за пределы массива или нет, если да, то итерация цикла просто
пропускается.

Вот и наступил конец видео, но грех не показать результат работы программы, поэтому сделал небольшую анимацию, которую вы сейчас можете лицезреть сразу с трёх ракурсов на своём экране,
подписывайтесь на канал, ставьте лайки, пишите комментарии и всем пока

